//
//  UnlockWorkerTests.swift
//  TheCloudLock
//
//  Created by Matheus Vasconcelos on 21/01/20.
//  Copyright (c) 2020 AppCompany. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import TheCloudLock
import XCTest

class DoorsWorkerTests: XCTestCase {
    // MARK: Subject under test
    
    var sut: DoorsWorker!
    
    // MARK: Test lifecycle
    
    override func setUp() {
        super.setUp()
        setupDoorsWorker()
    }
    
    override func tearDown() {
        super.tearDown()
    }
    
    // MARK: Test setup
    
    func setupDoorsWorker() {
        sut = DoorsWorker(cloudLock: CloudLockAPIFake())
    }
        
    // MARK: Tests
    
    func testUnlockDoorShouldCallCloudLockUnlockDoor() {
        let spy = CloudLockAPISpy()
        sut.cloudLock = spy
        
        sut.unlockDoor(doorID: "") { _ in }
        
        XCTAssert(spy.unlockDoorCalled, "unlockDoor should call CloudLockProtocol unlockDoor")
    }
    
    func testUnlockDoorShouldGetSuccessWhenStatusCodeFromCloudLockProtocol() {
        let spy = CloudLockAPISpy()
        sut.cloudLock = spy
        
        var status: Status?
        
        let completed = expectation(description: "waiting block completion")
        sut.unlockDoor(doorID: "") { result in
            status = result.data
            completed.fulfill()
        }
        
        waitForExpectations(timeout: 2.0, handler: nil)
        XCTAssertNotNil(status, "unlockDoor should get a status result from cloud lock protocol")
    }
    
    func testUnlockDoorShouldGetAuthErrorWhenStatusCode204FromCloudLockProtocol() {
        let fake = CloudLockAPIFake()
        fake.statusCode = 204
        sut.cloudLock = fake
        
        var error: CloudLockError?
        
        let completed = expectation(description: "waiting block completion")
        sut.unlockDoor(doorID: "") { result in
            error = result.error
            completed.fulfill()
        }
        let expected: CloudLockError? = .permissionDenied
        waitForExpectations(timeout: 2.0, handler: nil)
        XCTAssertEqual(error, expected, "unlockDoor should get permission denied error when status code 204")
    }
    
    // MARK: - FetchDoors
    
    func testFetchDoorsShouldCallCloudLockFetchDoors() {
        let spy = CloudLockAPISpy()
        sut.cloudLock = spy

        sut.fetchDoors { _ in }
        
        XCTAssertTrue(spy.fetchDoorsCalled, "fetchDoors should call CloudLockProtocol fetchDoors")
    }
    
    func testFetchDoorsShouldGetFetchedDoorsFromCloudLockProtocol() {
        let spy = CloudLockAPISpy()
        sut.cloudLock = spy
        
        var fetchedDoors: [Doors]?
        
        let completed = expectation(description: "waiting block to complete")
        sut.fetchDoors { result in
            fetchedDoors = result.data
            completed.fulfill()
        }
        
        waitForExpectations(timeout: 2.0, handler: nil)
        XCTAssertNotNil(fetchedDoors, "fetchDoors should have fetched doors passed to worker")
    }
    
    func testFetchDoorsShouldGetErrorWhenCloudLockProtocolGetsError() {
        let fake = CloudLockAPIFake()
        fake.success = false
        sut.cloudLock = fake
        
        var fetchError: CloudLockError?
        
        let completed = expectation(description: "waiting block to complete")
        sut.fetchDoors { result in
            fetchError = result.error
            completed.fulfill()
        }
        
        waitForExpectations(timeout: 2.0, handler: nil)
        
        guard let error = fetchError else {
            XCTFail("fetchDoors should have fetched error passed to worker")
            return
        }
        
        XCTAssertEqual(error, .cannotFetch, "fetchDoors should have fetched error passed to worker")
    }
}
